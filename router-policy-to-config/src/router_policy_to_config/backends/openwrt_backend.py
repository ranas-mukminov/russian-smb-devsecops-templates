"""
OpenWrt backend for generating UCI configuration.

Generates UCI configuration files for /etc/config/.
"""

import ipaddress
from typing import Dict, List

from router_policy_to_config.model import Policy


class OpenWrtBackend:
    """Generate OpenWrt UCI configuration from policy."""

    def __init__(self, policy: Policy):
        """
        Initialize OpenWrt backend.

        Args:
            policy: Policy instance to convert
        """
        self.policy = policy
        self.configs: Dict[str, List[str]] = {
            "network": [],
            "wireless": [],
            "firewall": [],
            "dhcp": [],
        }

    def _add_line(self, config: str, line: str) -> None:
        """Add a line to a specific config file."""
        self.configs[config].append(line)

    def _add_blank(self, config: str) -> None:
        """Add a blank line."""
        self.configs[config].append("")

    def _generate_network(self) -> None:
        """Generate /etc/config/network."""
        config = "network"

        # Header comment
        self._add_line(config, f"# Network configuration for: {self.policy.meta.name}")
        self._add_line(config, "# Generated by router-policy-to-config")
        self._add_blank(config)

        # Loopback interface (standard)
        self._add_line(config, "config interface 'loopback'")
        self._add_line(config, "\toption device 'lo'")
        self._add_line(config, "\toption proto 'static'")
        self._add_line(config, "\toption ipaddr '127.0.0.1'")
        self._add_line(config, "\toption netmask '255.255.255.0'")
        self._add_blank(config)

        # WAN interface
        wan = self.policy.wan
        self._add_line(config, "config interface 'wan'")
        self._add_line(config, f"\toption device '{wan.interface}'")

        if wan.type == "pppoe":
            self._add_line(config, "\toption proto 'pppoe'")
            self._add_line(config, f"\toption username '{wan.username}'")
            password = wan.password_ref or "<PASSWORD_NOT_SET>"
            self._add_line(config, f"\toption password '{password}'")
            if wan.mtu:
                self._add_line(config, f"\toption mtu '{wan.mtu}'")

        elif wan.type == "dhcp":
            self._add_line(config, "\toption proto 'dhcp'")

        elif wan.type == "static":
            self._add_line(config, "\toption proto 'static'")
            self._add_line(config, f"\toption ipaddr '{wan.ip}'")
            self._add_line(config, f"\toption netmask '{wan.netmask}'")
            if wan.gateway:
                self._add_line(config, f"\toption gateway '{wan.gateway}'")
            if wan.dns:
                dns_list = " ".join(wan.dns)
                self._add_line(config, f"\toption dns '{dns_list}'")

        self._add_blank(config)

        # LAN interfaces
        for lan in self.policy.lans:
            interface_name = lan.name if lan.name != "main" else "lan"

            self._add_line(config, f"config interface '{interface_name}'")

            if lan.vlan_id:
                device_name = f"br-{interface_name}.{lan.vlan_id}"
                self._add_line(config, f"\toption device '{device_name}'")
            else:
                device_name = f"br-{interface_name}"
                self._add_line(config, f"\toption device '{device_name}'")

            self._add_line(config, "\toption proto 'static'")
            self._add_line(config, f"\toption ipaddr '{lan.gateway}'")

            # Extract netmask from CIDR
            try:
                network = ipaddress.ip_network(lan.subnet, strict=False)
                netmask = str(network.netmask)
                self._add_line(config, f"\toption netmask '{netmask}'")
            except ValueError:
                self._add_line(config, "\toption netmask '255.255.255.0'")

            self._add_blank(config)

        # Bridge devices
        if self.policy.lans:
            for lan in self.policy.lans:
                interface_name = lan.name if lan.name != "main" else "lan"
                device_name = f"br-{interface_name}"

                self._add_line(config, f"config device")
                self._add_line(config, f"\toption name '{device_name}'")
                self._add_line(config, "\toption type 'bridge'")

                # Add ports if specified
                if lan.interface:
                    self._add_line(config, f"\tlist ports '{lan.interface}'")

                self._add_blank(config)

    def _generate_wireless(self) -> None:
        """Generate /etc/config/wireless."""
        if not self.policy.wifi:
            return

        config = "wireless"

        self._add_line(config, f"# Wireless configuration for: {self.policy.meta.name}")
        self._add_line(config, "# Generated by router-policy-to-config")
        self._add_blank(config)

        # Assume radio0 for 2.4GHz, radio1 for 5GHz
        radios_used = set()

        for wifi in self.policy.wifi:
            # Determine radio
            if wifi.band == "5ghz":
                radio = "radio1"
                hwmode = "11a"
            else:
                radio = "radio0"
                hwmode = "11g"

            # Configure radio if not done yet
            if radio not in radios_used:
                self._add_line(config, f"config wifi-device '{radio}'")
                self._add_line(config, f"\toption type 'mac80211'")
                self._add_line(config, f"\toption hwmode '{hwmode}'")

                if wifi.channel:
                    self._add_line(config, f"\toption channel '{wifi.channel}'")
                else:
                    self._add_line(config, "\toption channel 'auto'")

                self._add_line(config, "\toption htmode 'HT20'")
                self._add_line(config, "\toption disabled '0'")
                self._add_blank(config)

                radios_used.add(radio)

            # WiFi interface
            network_name = wifi.lan if wifi.lan != "main" else "lan"

            self._add_line(config, f"config wifi-iface")
            self._add_line(config, f"\toption device '{radio}'")
            self._add_line(config, f"\toption network '{network_name}'")
            self._add_line(config, f"\toption mode '{wifi.mode}'")
            self._add_line(config, f"\toption ssid '{wifi.ssid}'")

            if wifi.security:
                encryption = wifi.security.encryption
                # Map to UCI encryption format
                if encryption == "wpa2-psk":
                    self._add_line(config, "\toption encryption 'psk2'")
                elif encryption == "wpa3-psk":
                    self._add_line(config, "\toption encryption 'sae'")
                elif encryption == "wpa-psk":
                    self._add_line(config, "\toption encryption 'psk'")
                elif encryption == "none":
                    self._add_line(config, "\toption encryption 'none'")

                if wifi.security.password_ref:
                    password = wifi.security.password_ref or "<PASSWORD_NOT_SET>"
                    self._add_line(config, f"\toption key '{password}'")

            if wifi.hidden:
                self._add_line(config, "\toption hidden '1'")

            if wifi.guest:
                self._add_line(config, "\toption isolate '1'")

            self._add_blank(config)

    def _generate_firewall(self) -> None:
        """Generate /etc/config/firewall."""
        config = "firewall"

        self._add_line(config, f"# Firewall configuration for: {self.policy.meta.name}")
        self._add_line(config, "# Generated by router-policy-to-config")
        self._add_blank(config)

        # Defaults
        default_policy = "DROP" if not self.policy.firewall else self.policy.firewall.default_policy.upper()
        if default_policy == "ACCEPT":
            default_policy = "ACCEPT"

        self._add_line(config, "config defaults")
        self._add_line(config, "\toption input 'ACCEPT'")
        self._add_line(config, "\toption output 'ACCEPT'")
        self._add_line(config, f"\toption forward '{default_policy}'")
        self._add_line(config, "\toption synflood_protect '1'")
        self._add_blank(config)

        # WAN zone
        self._add_line(config, "config zone")
        self._add_line(config, "\toption name 'wan'")
        self._add_line(config, "\tlist network 'wan'")
        self._add_line(config, "\toption input 'REJECT'")
        self._add_line(config, "\toption output 'ACCEPT'")
        self._add_line(config, "\toption forward 'REJECT'")
        self._add_line(config, "\toption masq '1'")
        self._add_line(config, "\toption mtu_fix '1'")
        self._add_blank(config)

        # LAN zones
        for lan in self.policy.lans:
            zone_name = lan.name
            network_name = lan.name if lan.name != "main" else "lan"

            self._add_line(config, "config zone")
            self._add_line(config, f"\toption name '{zone_name}'")
            self._add_line(config, f"\tlist network '{network_name}'")
            self._add_line(config, "\toption input 'ACCEPT'")
            self._add_line(config, "\toption output 'ACCEPT'")
            self._add_line(config, "\toption forward 'ACCEPT'")
            self._add_blank(config)

        # VPN zone
        if self.policy.vpn:
            self._add_line(config, "config zone")
            self._add_line(config, "\toption name 'vpn'")
            self._add_line(config, "\toption input 'ACCEPT'")
            self._add_line(config, "\toption output 'ACCEPT'")
            self._add_line(config, "\toption forward 'ACCEPT'")
            self._add_blank(config)

        # Forwardings
        for lan in self.policy.lans:
            zone_name = lan.name

            # Check if this LAN is isolated
            if "main" not in lan.isolated_from:
                # Allow LAN to WAN
                self._add_line(config, "config forwarding")
                self._add_line(config, f"\toption src '{zone_name}'")
                self._add_line(config, "\toption dest 'wan'")
                self._add_blank(config)

        # VPN to LAN forwarding
        if self.policy.vpn:
            self._add_line(config, "config forwarding")
            self._add_line(config, "\toption src 'vpn'")
            self._add_line(config, "\toption dest 'lan'")
            self._add_blank(config)

        # Custom firewall rules
        if self.policy.firewall:
            for rule in self.policy.firewall.rules:
                self._add_line(config, "config rule")
                self._add_line(config, f"\toption name '{rule.name}'")

                if rule.from_zones:
                    src = rule.from_zones[0].replace("main", "lan")
                    self._add_line(config, f"\toption src '{src}'")

                if rule.to_zones:
                    dest = rule.to_zones[0].replace("main", "lan")
                    self._add_line(config, f"\toption dest '{dest}'")

                if rule.protocol:
                    self._add_line(config, f"\toption proto '{rule.protocol}'")

                if rule.port:
                    self._add_line(config, f"\toption dest_port '{rule.port}'")

                target = rule.action.upper()
                self._add_line(config, f"\toption target '{target}'")

                self._add_blank(config)

        # Port forwards
        if self.policy.nat and self.policy.nat.port_forwards:
            for pf in self.policy.nat.port_forwards:
                name = pf.name or f"forward_{pf.external_port}"

                self._add_line(config, "config redirect")
                self._add_line(config, f"\toption name '{name}'")
                self._add_line(config, "\toption src 'wan'")
                self._add_line(config, "\toption dest 'lan'")

                protocol = pf.protocol
                if protocol == "both":
                    self._add_line(config, "\tlist proto 'tcp'")
                    self._add_line(config, "\tlist proto 'udp'")
                else:
                    self._add_line(config, f"\toption proto '{protocol}'")

                self._add_line(config, f"\toption src_dport '{pf.external_port}'")
                self._add_line(config, f"\toption dest_ip '{pf.internal_ip}'")
                self._add_line(config, f"\toption dest_port '{pf.internal_port}'")
                self._add_line(config, "\toption target 'DNAT'")
                self._add_blank(config)

    def _generate_dhcp(self) -> None:
        """Generate /etc/config/dhcp."""
        config = "dhcp"

        self._add_line(config, f"# DHCP configuration for: {self.policy.meta.name}")
        self._add_line(config, "# Generated by router-policy-to-config")
        self._add_blank(config)

        # dnsmasq configuration
        self._add_line(config, "config dnsmasq")
        self._add_line(config, "\toption domainneeded '1'")
        self._add_line(config, "\toption boguspriv '1'")
        self._add_line(config, "\toption localise_queries '1'")
        self._add_line(config, "\toption rebind_protection '1'")
        self._add_line(config, "\toption rebind_localhost '1'")
        self._add_line(config, "\toption local '/lan/'")
        self._add_line(config, "\toption domain 'lan'")
        self._add_line(config, "\toption expandhosts '1'")
        self._add_line(config, "\toption authoritative '1'")
        self._add_line(config, "\toption readethers '1'")
        self._add_line(config, "\toption leasefile '/tmp/dhcp.leases'")
        self._add_line(config, "\toption resolvfile '/tmp/resolv.conf.d/resolv.conf.auto'")
        self._add_blank(config)

        # DHCP pools for LANs
        for lan in self.policy.lans:
            if lan.dhcp and lan.dhcp.enabled:
                interface_name = lan.name if lan.name != "main" else "lan"

                self._add_line(config, "config dhcp")
                self._add_line(config, f"\toption interface '{interface_name}'")

                # Parse DHCP range
                if lan.dhcp.range:
                    try:
                        start_ip, end_ip = lan.dhcp.range.split("-")
                        start_ip = start_ip.strip()
                        end_ip = end_ip.strip()

                        # Calculate start offset from network
                        network = ipaddress.ip_network(lan.subnet, strict=False)
                        start_addr = ipaddress.ip_address(start_ip)
                        start_offset = int(start_addr) - int(network.network_address)

                        end_addr = ipaddress.ip_address(end_ip)
                        limit = int(end_addr) - int(start_addr) + 1

                        self._add_line(config, f"\toption start '{start_offset}'")
                        self._add_line(config, f"\toption limit '{limit}'")
                    except (ValueError, AttributeError):
                        # Fallback
                        self._add_line(config, "\toption start '100'")
                        self._add_line(config, "\toption limit '150'")
                else:
                    self._add_line(config, "\toption start '100'")
                    self._add_line(config, "\toption limit '150'")

                self._add_line(config, f"\toption leasetime '{lan.dhcp.lease_time}'")
                self._add_blank(config)

    def generate(self) -> Dict[str, str]:
        """
        Generate complete OpenWrt UCI configuration.

        Returns:
            Dictionary mapping config file names to their contents
        """
        self.configs = {
            "network": [],
            "wireless": [],
            "firewall": [],
            "dhcp": [],
        }

        # Generate all config files
        self._generate_network()
        self._generate_wireless()
        self._generate_firewall()
        self._generate_dhcp()

        # Convert to strings
        result = {}
        for name, lines in self.configs.items():
            if lines:  # Only include non-empty configs
                result[name] = "\n".join(lines)

        return result

    def generate_commands(self) -> List[str]:
        """
        Generate UCI commands to apply configuration.

        Returns:
            List of UCI commands
        """
        commands = []
        configs = self.generate()

        commands.append("# UCI commands to apply configuration")
        commands.append("# Warning: Review before applying!")
        commands.append("")

        for config_name, content in configs.items():
            commands.append(f"# Apply {config_name} configuration")
            commands.append(f"cat > /tmp/{config_name}.new << 'EOF'")
            commands.append(content)
            commands.append("EOF")
            commands.append(f"mv /tmp/{config_name}.new /etc/config/{config_name}")
            commands.append("")

        commands.append("# Reload configurations")
        commands.append("/etc/init.d/network reload")
        commands.append("/etc/init.d/firewall reload")
        commands.append("/etc/init.d/dnsmasq reload")

        if self.policy.wifi:
            commands.append("wifi reload")

        return commands
